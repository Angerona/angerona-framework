options{  STATIC = false;}PARSER_BEGIN(MotivationParser)package com.github.angerona.fw.motivation.parser;import static com.github.angerona.fw.motivation.utils.FormulaUtils.createDesire;import static com.github.angerona.fw.motivation.utils.FormulaUtils.createFormula;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;import net.sf.tweety.logics.fol.syntax.FolFormula;import com.github.angerona.fw.Desire;import com.github.angerona.fw.motivation.Maslow;import com.github.angerona.fw.motivation.model.Motive;import com.github.angerona.fw.motivation.model.MotiveCoupling;import com.github.angerona.fw.motivation.model.WeightRange;import com.github.angerona.fw.util.Pair;public class MotivationParser{  public static void main(String [] args) throws ParseException, TokenMgrError  {    new MotivationParser(System.in);  }}PARSER_END(MotivationParser)SKIP :{  " "| "\t"| "\n"| "\r"| "\r\n"}TOKEN :{  < NUMBER :    ("-")? ([ "0"-"9" ])+    (      "." ([ "0"-"9" ])+    )? >}TOKEN :{  < KEYWORD : [ "a"-"z", "A"-"Z", "_" ] ([ "a"-"z", "A"-"Z", "_", "0"-"9" ])* >}TOKEN :{  < NEG : "-" >}TOKEN :{  < OPEN : "[" >}TOKEN :{  < CLOSE : "]" >}TOKEN :{  < KOMMA : "," >}TOKEN :{  < OPAR : "(" >}TOKEN :{  < CPAR : ")" >}TOKEN :{  < DIV : ";" >}Pair < Double, Double > readNumPair() :{  Double fst;  Double snd;}{  < OPEN >  {    fst = readNumber();  }  < KOMMA >  {    snd = readNumber();  }  < CLOSE >  {    return new Pair < Double, Double > (fst, snd);  }}Pair < String, String > readKeyPair() :{  String fst;  String snd;}{  < OPEN >  {    fst = readKeyword();  }  < KOMMA >  {    snd = readKeyword();  }  < CLOSE >  {    return new Pair < String, String > (fst, snd);  }}Double readNumber() :{  Token t;}{  t = < NUMBER >  {    return Double.parseDouble(t.image);  }}String readKeyword() :{  Token t;}{  t = < KEYWORD >  {    return t.image;  }}Set < MotiveCoupling < Maslow, FolFormula >> gatherCouplings() :{  Set < MotiveCoupling < Maslow, FolFormula >> set = new HashSet < MotiveCoupling < Maslow, FolFormula >> ();  Motive < Maslow > m;  Desire d;  Double cs;  FolFormula f;  String str;  boolean negation;}{  (    < OPAR >    {      m = readMotive();    }    < DIV >    {      d = createDesire(readFormula());    }    < DIV >    {      cs = readNumber();    }    < DIV >    {      f = createFormula(readFormula());    }    < CPAR >    {      set.add(new MotiveCoupling < Maslow, FolFormula > (m, d, cs, f));    }    < DIV >  )*  < EOF >  {    return set;  }}Motive < Maslow > readMotive() :{  Pair < String, String > pair;}{  {    pair = readKeyPair();    return new Motive < Maslow > (pair.first, Maslow.valueOf(pair.second));  }}String readFormula() :{  Token neg = null;}{  (neg = < NEG >)?  {    return (neg != null ? neg.image : "") + readKeyword();  }}Map < Maslow, WeightRange > gatherRanges() :{  Map < Maslow, WeightRange > map = new HashMap < Maslow, WeightRange > ();  Maslow level;  WeightRange range;}{  (    < OPAR >    {      level = Maslow.valueOf(readKeyword());    }    < DIV >    {      range = readRange();    }    < CPAR > < DIV >    {      map.put(level, range);    }  )*  < EOF >  {    return map;  }}WeightRange readRange() :{  Pair < Double, Double > pair;}{  {    pair = readNumPair();    return new WeightRange(pair.first, pair.second);  }}