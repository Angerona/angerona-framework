Secrecy aware BDI Agent Model	{#secrecyawarebdiagentmodel}
=============================

The secrecy aware BDI agent model is an extension of the BDI agent model,
that allows agents to act in an environment and fulfill confidentiality 
constraints. This article explains how the secrecy agent model is implemented 
in the KReatures framework. 

This article assumes that you have read and understand @ref conceptoperators article.
It also assumes that you have read the conceptual part of the KReatures technical
report, such that you understand how the secrets and the belief change works 
and that you are aware of the operators that are used in the secrecy agent model. 

The article links different concepts that are introduced in
the technical report of the KReatures framework to Java interfaces and base classes. 
The implementation can be found by searching for sub classes and example implementations 
are also given in the project: *com.github.kreatures.example*.



Components in the Secrecy Agent Model
-------------------------------------

The secrecy agent model adds a component @ref com.github.kreatures.am.secrecy.components.SecrecyKnowledge that
acts as data-storage for secrets. A secret is a tuple as defined in the technical-report and is represented
by the class @ref com.github.kreatures.am.secrecy.Secret. To change the SecrecyKnowledge a helper class 
@ref com.github.kreatures.am.secrecy.SecrecyChangeProposal is used that acts as representation for the changes.
It's realize() method does the real changes. In fact a SecrecyChangeProposal is a collection of 
@ref com.github.kreatures.am.secrecy.SecretChangeProposal instances. The SecrecyChangeProposal is also used to
process the distance that is generated by the proposed changes. That means it is possible to compare two 
SecrecyChangeProposal instances by their impact on the SecrecyKnowledge

The belief operator families explained in the report are given by the interface 
@ref com.github.kreatures.operators.BeliefOperatorFamily, that is implemented in two ways: As a discrete version, that 
contains every belief operator in a set (see @ref com.github.kreatures.operators.DiscreteBeliefOperatorFamily) 
or a continuous version that is implemented using the Strategy pattern (see 
@ref com.github.kreatures.operators.ContinuousBeliefOperatorFamily).

There are components, like Desires and Plan, that are also useful for other BDI instantiations, not only the secrecy
agent model. The Desires component is given by @ref com.github.kreatures.core.logic.Desires and is in fact a collection
of desires that are implemented by @ref com.github.kreatures.Desire. The plan component given by 
@ref com.github.kreatures.PlanComponent is more complex. It is a collection of parentless subgoal instances, whereby a subgoal
that has no parent is referred to as *plan*. The implementation of a subgoal is given by 
@ref com.github.kreatures.Subgoal. A subgoal consists of a set of stacks, each of these stacks represents a plan, whereby
it's semantic is given by the using classes, such that the stacks can be seen either as parallel or alternative plans. In every
implementation in KReatures so far the stacks are used as alternative plans. The elements of the stacks are intentions, which are
either abstract intentions implemented by subgoals or atomic intentions which are extension of the abstract Action base class 
(see @ref com.github.kreatures.Action).

Operators in the Secrecy Agent Model
------------------------------------

The secrecy agent model consists of five different operation types:

- **Belief Change** is responsible to change the agent's beliefs by using a perception. This
  operation type is given by @ref com.github.kreatures.operators.BaseUpdateBeliefsOperator.
  Implementation shall invoke onUpdateBeliefs on their agent instance to inform other components
  when the belief change process is finished.
- **Generate Options** is responsible to generate the agent's desires, therefore it uses it's beliefs and
  it's current desires. This operation type is given by @ref com.github.kreatures.am.secrecy.operators.BaseGenerateOptionsOperator.
  Implementation might work with the @ref com.github.kreatures.core.logic.Desires component to store newly created desires.
- **Intention Update** is responsible to select the next action of the agent and to process abstract intentions. That
  means it outputs the next action and uses **Subgoal Generation** to break abstract intentions into less abstract 
  intentions. This operation type is given by @ref com.github.kreatures.am.secrecy.operators.BaseIntentionUpdateOperator.
  Implementations might work with the @ref com.github.kreatures.PlanComponent component to select the actions.
- **Subgoal Generation** is responsible to turn abstract intentions into sub-goals whereby a plan is generated and therefore
  it uses the @ref com.github.kreatures.PlanComponent component like **Intention Update** but writes to it. It's operation type is given
  by @ref com.github.kreatures.am.secrecy.operators.BaseSubgoalGenerationOperator. 
- **Violates** differentiates from the previous operators because it only reads data but does not write to the agent's
  data components. It checks if a specific action/perception or an entire plan violates the secrecy of the agent. It's
  operation type is given by @ref com.github.kreatures.am.secrecy.operators.BaseViolatesOperator. Currently **Violates**
  is invoked by **Intention Update** and **Subgoal Generation** implementations.



Conclusion
----------

This article links the classes of the Java implementation to the concepts of the technical report of KReatures and is therefore
a good reference/starting point to find the Java code responsible to implement different parts of the secrecy agent model.