% calculates the next action of an agent.
% Know-How is defined in "Know-How for Motivated
% BDI Agents" by Matthias Thimm and Patrick Krï¿½mpelmann.
% Adaptions discussed in Regina Fritsch's diploma thesis 
% to the 'NextAction' program were used.
% uses the dlv-complex syntax for list operations.

% rules for state: 'intentionAdded'
new_act(A) :- state(intentionAdded), istack(S), is_atomic(A), #head(S, A).
new_subgoal(I) :- state(intentionAdded), istack(S), is_atomic(A), #head(S, A), khsubgoal(KH, I, A).
new_khstate([KH|K]) :- state(intentionAdded), khstate(K), khstatement(KH, I), istack(S), #head(S, I), not khconditionfail(K), not khfailed([KH|K]), not const_new_act, not multiple.
new_khstate([KH|K]) :- state(intentionAdded), khstate(K), khstatement(KH, I), khstatement(KHA, I), istack(S), #head(S, I), not khconditionfail(K), not khfailed([KH|K]), not const_new_act, multiple, not new_khstate([KHA|K]), KHA!=KH.
new_khfailed(K) :- state(intentionAdded), khstate(K), not const_new_act, not const_new_khstate.
toparent :- const_new_khfailed.
% --- READY --- 

% rules for state: 'actionPerformed'
new_istack([INT_C|INT_B]) :- state(actionPerformed), istack([INT_A|INT_B]), khstate(L), #head(L, KH), khsubgoal(KH, I, INT_A), khsubgoal(KH, J, INT_C), J=I+1.
new_khperformed(KH) :- state(actionPerformed), khstate(L), #head(L, KH), not khperformed_helper(KH). 
toparent :- new_khperformed(X).
% --- READY ---

% rule for state: 'khAdded'
new_istack([INT_I|INT_B]) :- state(khAdded), istack(INT_B), khsubgoal(KH,1,INT_I), khstate(L), #head(L, KH).
% --- READY ---

% state transition rules:
new_state(actionPerformed) :- new_act(A).
new_state(intentionAdded) :- new_istack(L), not const_new_khperformed. % Regina uses another version but I think this will do the same.
new_state(intentionAdded) :- const_new_khfailed, not new_istack([]).
new_state(khAdded) :- const_new_khstate, not const_new_khperformed, not lastknowhowstatement.
new_state(noop) :- new_istack([]).
new_khstate(K) :- toparent, khstate([KH|K]).
% Not sure why Regina used the following rule:
new_state(noop) :- state(noop). 
% --- READY ---

% the following rule is responsible to inform the
% system if a condition fails.
khconditionfail(KH) :- khcondition(KH,X), not holds(X).
% --- READY ---

% a rule which signals that no knowhow statement is left
% and therefore a switch to the parent is senseful.
lastknowhowstatement :- khstate([]), state(actionPerformed).
toparent :- lastknowhowstatement.
% --- READY ---

% helper rules. Without these rules one would create unsafe rules and dlv-complex would complain.
const_new_khperformed :- new_khperformed(P).
const_new_act :- new_act(A).
const_new_khstate :- new_khstate(KH).
const_new_khfailed :- new_khfailed(KH).
const_new_istack :- new_istack(I).
khperformed_helper(KH) :-  istack(S), #head(S,A), khsubgoal(KH,I,A), khsubgoal(KH,J,_), J=I+1.

% multiple is used to determine which new_khstate rule should be used.
multiple :- khstatement(KHA, I), khstatement(KHB, I), istack(S), #head(S, I), KHA!=KHB.

% --- READY ---