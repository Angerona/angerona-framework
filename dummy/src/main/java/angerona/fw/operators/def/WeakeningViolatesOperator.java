package angerona.fw.operators.def;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import net.sf.tweety.Formula;
import net.sf.tweety.logicprogramming.asplibrary.syntax.Literal;
import net.sf.tweety.logicprogramming.asplibrary.syntax.Program;
import net.sf.tweety.logicprogramming.asplibrary.syntax.Rule;
import net.sf.tweety.logicprogramming.asplibrary.util.AnswerSet;
import net.sf.tweety.logics.firstorderlogic.syntax.FolFormula;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import angerona.fw.BaseBeliefbase;
import angerona.fw.comm.Answer;
import angerona.fw.comm.DetailQueryAnswer;
import angerona.fw.logic.ConfidentialKnowledge;
import angerona.fw.logic.Secret;
import angerona.fw.logic.SecrecyStrengthPair;
import angerona.fw.logic.asp.AspBeliefbase;
import angerona.fw.logic.asp.AspReasoner;
import angerona.fw.operators.parameter.ViolatesParameter;
/**
 * Extension of my DetailSimpleViolatesOperator which enables one to weaken secrecy
 * @author dilger
 *
 */
public class WeakeningViolatesOperator extends DetailSimpleViolatesOperator {
	static final double INFINITY = 1000.0;
	
	@Override
	protected Boolean processInt(ViolatesParameter param) {
		this.weakenings = processIntAndWeaken(param);
		//Not sure whether or not to call the super.processInt()
		return false;
		//return super.processInt(param);
	}
	private Rule convertToRule(FolFormula f)
	{
		String ruleString = f.toString();
		ruleString += "."; //Assume information given is always a fact
		//Quick fix to bridge representations of ! and -
		if(ruleString.startsWith("!"))
		{
			ruleString = "-" + ruleString.substring(1);
		}
		//TODO: Account for predicates with variables (arity 1+) 
		Rule rule = new Rule(ruleString);
		return rule;
	}
	private List<SecrecyStrengthPair> representTotalExposure(ConfidentialKnowledge conf)
	{
		return null;
	}
	//This function no longer needed
	private boolean formulaMatchesLiteral(FolFormula secretInfo, Literal literal)
	{
		return false;
	}
	
	//Talk about generalizing the cost of weakening secrecy through either some multiplier coefficient,
	//or a non-linear cost calculation through either increasing frequency of belief operators 
	//or cost between the "edges" from one belief operator to another
	private double calculateSecrecyStrength(FolFormula secretInfo, List<AnswerSet> ansSets)
	{
		double numAnsSets = ansSets.size();
		double setsWithSecret = 0.0;
		for(AnswerSet as : ansSets)
		{
			Program p = as.toProgram();
			Rule secretRule = convertToRule(secretInfo);
			System.out.println("(Delete) secretRule: "+secretRule);
			System.out.println("(Delete) answer set program:"+p.toString());
			if(p.hasRule(secretRule))
			{
				setsWithSecret += 1;
			}
		}
		double quotient = setsWithSecret/numAnsSets;
		double strength = 1.0 - quotient;
		System.out.println("(Delete) Quotient: "+quotient+" strength: "+strength);
		return strength;
	}
	protected List<SecrecyStrengthPair> processIntAndWeaken(ViolatesParameter param)
	{
		Logger LOG = LoggerFactory.getLogger(DetailViolatesOperator.class);
		List<SecrecyStrengthPair> secretList = new LinkedList<SecrecyStrengthPair>(); 
		
		/* Check if any confidential knowledge present. If none then no secrecy weakening possible */
		ConfidentialKnowledge conf = param.getAgent().getComponent(ConfidentialKnowledge.class);
		if(conf == null)
			return secretList;
		
		/* Remaining operations depend on whether the action in question is an answer */
		if(param.getAction() instanceof Answer) 
		{
			Answer a = (Answer) param.getAction();
			Map<String, BaseBeliefbase> views = param.getBeliefs().getViewKnowledge();
			if(views.containsKey(a.getReceiverId())) 
			{
				
				AspBeliefbase view = (AspBeliefbase) views.get(a.getReceiverId()).clone();
				Program prog = view.getProgram();
				
				DetailQueryAnswer dqa = ((DetailQueryAnswer) a);
				LOG.info("Make Revision for DetailQueryAnswer: '{}'", dqa.getDetailAnswer());
				
				FolFormula answerFormula = dqa.getDetailAnswer();
				Rule rule = convertToRule(answerFormula);
				
				prog.add(rule);
				
				/*Check for contradictions. If one is found consider all secrets totally revealed*/ 
				List<AnswerSet> newAnsSets = null; //Should this be a set? Will it pass as a list?
				//This try/catch may be a crude solution but...
				//Actually, is try/catch even necessary in this case?
				try
				{
					//Actually I don't think the solution below was even necessary. It wasn't a bug, just bad output
					//Ensure the reasoning operator's belief base is up to date
					//Ask Tim about this solution?
					AspReasoner ar = (AspReasoner) view.getReasoningOperator();
					//ar.infer(view);
					System.out.println("(Delete) ar.infer view:"+ar.infer(view));
					System.out.println("(Delete) view.infere:"+view.infere());
					newAnsSets = ar.processAnswerSets();
					prog = view.getProgram(); //Necessary to update according to facts generated by rules
					System.out.println("(Delete) program after expansion:"+prog.toString());
					//System.out.println("(Delete) newAnsSets:"+newAnsSets.toString());
				}
				catch (IndexOutOfBoundsException ie)
				{
					//System.out.println("(Delete) IndexOutOfBounds processing answer sets");
				}
				if (newAnsSets==null)
				{
					//There is a bug with contradiction checking
					System.out.println("(Delete) contradiction noted here");
					report(param.getAgent().getName() + "' creates contradiction by: '" + param.getAction() + "'", view);
					secretList = representTotalExposure(conf);
					return secretList;
				}
				for(AnswerSet ans : newAnsSets)
				{
					System.out.println("(Delete) New Answer Set:"+ans.toString());
					
				}
				/* Now the secrecy strengths get added */
				for(Secret secret : conf.getTargets()) 
				{
					FolFormula secretInfo = (FolFormula) secret.getInformation(); //Info stored as a FolFormula in secret, yet access as a Formula...
					Rule secretRule = convertToRule(secretInfo);
					System.out.println("(Delete) information regarding secret: "+secret.toString());
					//better form to use hasRule instead of contains (though technically doesn't matter here)
					//hasRule is a deep comparison while contains is reference-based (for now)
					//if(prog.hasRule(secretRule))
					//if(view.infere().contains(secretInfo)) //Temporary fix until programs updated according to rules
					//but another problem is that the intersection of answer sets is what shows up in infer()
					
					//The below solution is the best I could come up with for rules
					boolean secretContained = false;
					for(AnswerSet ans : newAnsSets)
					{
						//Another temporary string-based solution...
						if(ans.toString().contains(secretInfo.toString()))
						{
							secretContained = true;
						}
					}
					if(secretContained)
					{
						
						SecrecyStrengthPair sPair = new SecrecyStrengthPair();
						sPair.defineSecret(secret);
						double newStrength = calculateSecrecyStrength(secretInfo, newAnsSets);
						//Note: the line below will crash if the belief operator specified is "DEFAULT"
						double curStrength = Double.parseDouble(secret.getReasonerParameters().get("d"));
						System.out.println("(Delete) curStrength: "+curStrength);
						double degreeOfWeakening = curStrength - newStrength;
						System.out.println("(Delete) degreeOfWeakening: "+degreeOfWeakening);
						/* Revealing a single secret entirely may not necessarily mean infinite cost...look over semantics again
						if(degreeOfWeakening == 1.0) //Represent the total weakening of a secret
							degreeOfWeakening = INFINITY;
							*/ 
						sPair.defineDegreeOfWeakening(degreeOfWeakening);
						secretList.add(sPair);
						report(param.getAgent().getName() + "' weakens secret: '"+secretInfo.toString()+"' by: '"+degreeOfWeakening+"' with: '" 
						+ param.getAction() + "'", view);
					}
					
				}
			}
		}
		
		return secretList;
	}
}
