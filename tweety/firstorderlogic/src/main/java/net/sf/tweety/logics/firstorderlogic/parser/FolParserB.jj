/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
  JDK_VERSION = "1.5";
  static = false;
}

PARSER_BEGIN(FolParserB)
package net.sf.tweety.logics.firstorderlogic.parser;

import java.util.*;
import net.sf.tweety.logics.firstorderlogic.syntax.*;
import net.sf.tweety.util.Pair;

import net.sf.tweety.logics.firstorderlogic.FolBeliefSet;

@SuppressWarnings("all")
public class FolParserB
{ 
  public void setForce(boolean forceDefinitions)  {
    this.forceDefinitions = forceDefinitions;  }
  private boolean forceDefinitions = false;

  private FolFormula helper(FolFormula form, Pair<Integer, FolFormula > exform)	throws ParseException
  {
    FolFormula reval = null;
    if(exform.getFirst() == 0)    {
      return form;    }
    if(exform.getFirst() == 1)    {
      return new Conjunction(form, exform.getSecond());    }
    if(exform.getFirst() == 2)
    {      return new Disjunction(form, exform.getSecond());    }    throw new ParseException("Error");  }

  /**
   *
   */
  private List<Sort > getSorts(FolSignature sig, List<String > names)
	throws ParseException
  {
    List<Sort >reval = new LinkedList<Sort >();
    for(String name : names)
    {
      Sort s = sig.getSort(name);
      if(s == null)      {
        if(forceDefinitions)
        {
          throw new ParseException("Sort with name '" + name + "' was not defined.");        }
        else
        {
          s = new Sort(name);
      	  sig.add(s);
        }      }    }
    return reval;  }

  private Functor getFunctor(String name, FolSignature signature)
  {
    return signature.getFunctor(name);  }

  private Functor getOrCreateFunctor(String name, List<Term >args, Sort targetSort, FolSignature signature)
  	throws ParseException  {
    Functor reval = signature.getFunctor(name);
    if(reval == null)    {
      if(forceDefinitions)      {
        throw new ParseException("Functor with name '" + name + "' was not defined.");      }
      else
      {
        List<Sort >sorts = new LinkedList<Sort >();
        for(Term t : args)        {
          sorts.add(t.getSort());        }
        reval = new Functor(name, sorts, targetSort);      }    }
    return reval;  }

  private Predicate getPredicate(String name, FolSignature sig)
  {
    return sig.getPredicate(name);  }

  private Sort getArgumentType(FolBasicStructure fbs, int count)
    throws ParseException
  {
    if(fbs == null)
    {
      return Sort.THING;    }
    if(count >= fbs.getArguments().size())
    {
	  return null;    }

    return fbs.getArguments().get(count);  }
}

PARSER_END(FolParserB)

/* BNF: adapt old BNF of fol-tweety to have optional signatures and change negation symbol
 * from '!' to '-'. Because '-' was used for contradition we use '!' for contradictions now.
 * knowledge base is given by (starting symbol is KB)
 *
 * KB 			::== (SORTSDEC DECLAR)? FORMULAS
 * DECLAR		::== (FUNCTORDEC | PREDDEC)*
 * SORTSDEC     ::== ( SORTNAME "=" "{" (CONSTANTNAME ("," CONSTANTNAME)*)? "}" "\n" )*
 * PREDDEC		::== "type" "(" PREDICATENAME ("(" SORTNAME ("," SORTNAME)* ")")? ")" "\n"
 * FUNCTORDEC	::== "type" "(" SORTNAME "=" FUNCTORNAME "(" (SORTNAME ("," SORTNAME)*)? ")" ")" "\n"
 * FORMULAS     ::== (FORMULA)*
 * FORMULA      ::== ATOM | "forall" VARIABLENAME ":" "(" FORMULA ")" | "exists" VARIABLENAME ":" FORMULA |
 * 					 "(" FORMULA ")" | FORMULA "&&" FORMULA | FORMULA "||" FORMULA | "-" FORMULA | "+" | "!"
 * ATOM			::== PREDICATENAME ("(" TERM ("," TERM)* ")")?
 * TERM			::== VARIABLENAME | CONSTANTNAME | FUNCTORNAME "(" (TERM ("," TERM)*)?  ")" 
 *  
 * where SORTNAME, PREDICATENAME, CONSTANTNAME, VARIABLENAME, and FUNCTORNAME are sequences of
 * symbols from {a,...,z,A,...,Z,0,...,9} with a letter at the beginning.
 *
 * javacc forbids left recursion therefore we will make FORMULA a non left-recursiv rule
 * and add the rule FORMULAEX:
 * FORMULA		::== ATOM FORMULAEX | "forall" VARIABLENAME ":" "(" FORMULA FORMULAEX ")" | "exists VARIABLENAME ":" "(" FORMULA FORMULAEX ")" |
 *					 "(" FORMULA FORMULAEX ")" | "-" FORMULA FORMULAEX | "+" | "!"
 * FORMULAEX	::== "&&" FORMULA | "||" FORMULA
 */

SKIP :
{
  " "
| "\n"
| "\r"
| "\t"
| <"%" (~["\n"])*>
}

TOKEN : /* OPERATORS */
{
  < FORALL : "forall" >
| < EXISTS : "exist" >
| < TYPE : "type" >
| < DDOT : ":"  >
| < EQUAL : "=" >
| < OR : "||" >
| < AND : "&&" >
| < NOT: "-" >
| < TAUTOLOGY: "+" >
| < CONTRADICTION: "!" >
| < LBRA : "(" >
| < RBRA : ")" >
| < SQLBRA : "[" >
| < SQRBRA : "]" >
| < CURLBRA : "{" >
| < CURRBRA : "}" >
}

TOKEN :
{
  < DIGIT : [ "0"-"9" ] >
| < NUMBER : (< DIGIT >)+ >
| < LCHAR : ["a"-"z"]>
| < UCHAR : ["A"-"Z"] >
| < SYMBOL: (< LCHAR >|< UCHAR >|< DIGIT >) >
| < CONSTANT: < LCHAR >(< SYMBOL >)* >
| < VARIABLE: < UCHAR >(< SYMBOL >)* >
| < BLANK : "_" >
| < COMMA : "," >
}

FolBeliefSet KB() :{
  List<Sort > sorts;
  FolFormula ff;
  FolBeliefSet bb = new FolBeliefSet();
  FolSignature signature = (FolSignature)bb.getSignature();}
{
 (
   LOOKAHEAD(2)
   sorts = sortdecl()
   {
     for(Sort s : sorts)     {
       signature.add(s);     }
   }
   declar(signature) )?
 (
   ff = formula(signature)   {
     bb.add(ff);    }
 )*

 {
   return bb; }
}

FolFormula formula(FolSignature signature) :
{
  Token t;
  FolFormula temp;
  Pair<Integer, FolFormula > ex;
  FolFormula reval;
  Variable v = null;}
{
  (  
	  (
	    temp = atom(signature) ex = formulaex(signature)
	    {
	      reval = helper(temp, ex);	    }	  )
	  | 
	  (
	    < FORALL > t = < VARIABLE > < DDOT > temp = formula(signature) ex = formulaex(signature)	    {
	      v = new Variable(t.image);
	      reval = new ForallQuantifiedFormula(helper(temp, ex), v);	    } 	  )
	  |
	  (
	    < EXISTS > t = < VARIABLE > < DDOT > temp = formula(signature) ex = formulaex(signature)
	    {
	      v = new Variable(t.image);
	      reval = new ExistsQuantifiedFormula(helper(temp, ex), v);	    }	  )
	  |
	  (
	    < NOT > temp = formula(signature) ex = formulaex(signature)
	    {
	      reval = new Negation(helper(temp, ex));	    }	  )
	  |
	  (
	    < CONTRADICTION >
	    {
	      reval = new Contradiction();	    }	  )
	  |
	  (
	    < TAUTOLOGY >
	    {
	      reval = new Tautology();	    }	  )
  )    
  {
    return reval;  } }

Pair<Integer, FolFormula> formulaex(FolSignature signature) :
{
  
  Integer status = 0; // 0 nothing, 1 and, 2 or
  FolFormula form = null;
  Pair<Integer, FolFormula> reval = new Pair<Integer, FolFormula>();}
{
  (
    (   
      < AND > form = formula(signature)
      {        status = 1;
      }    )
    |
    (
      < OR > form = formula(signature)
      {        status = 2;
      }    )
  )?
  {
    reval.setFirst(status);
    reval.setSecond(form);
    return reval;  }}

Atom atom(FolSignature signature) :
{
  String identifier;
  Term t;
  Atom reval;
  Predicate p;
  int count = 0;
  Sort type;
  List<Term > terms = new LinkedList<Term >();}
{
  identifier = identifier()
  {
    p = getPredicate(identifier, signature);
    type = getArgumentType(p, count++);  }
  (
    < LBRA >
  	t = term(signature, type)  	{
  	  terms.add(t);
  	  type = getArgumentType(p, count++);  	}
  	(
  	  < COMMA >
  	  t = term(signature, type)
  	  {
  	    terms.add(t);
  	    type = getArgumentType(p, count++);  	  }  	)*
    < RBRA >
  )?
  {
    if(p == null)
    {
      p = new Predicate(identifier, terms.size());
      signature.add(p);
	}
    reval = new Atom(p, terms);    return reval;
  }}

Term term(FolSignature signature, Sort type) :
{
  Term temp;
  String fname;
  int count = 0;
  Sort subtype;
  Functor f;
  List<Term > terms = new LinkedList<Term >();}
{
  fname = identifier()
  {
      f = getFunctor(fname, signature);
      subtype = getArgumentType(f, count++);
  }
  ( 
    < LBRA >
    temp = term(signature, subtype)
	{
	  terms.add(temp);
	  subtype = getArgumentType(f, count++);
	}
    (
      < COMMA >
      temp = term(signature, subtype)
      {
        terms.add(temp);
        subtype = getArgumentType(f, count++);      }    )*  
    < RBRA >
    {
      return new FunctionalTerm(getOrCreateFunctor(fname, terms, type, signature), terms);    }  )?
  
  // TODO Functor 
  {
    if(fname.charAt(0) < 97)
    {
      return new Variable(fname);    }
    else
    {
      return new Constant(fname);    }  }}
String identifier() :
{
  Token t;}
{
  (    
    (      t = < CONSTANT >
    )
    |
    (
      t = < VARIABLE >    )
  )
  {
    return t.image;  }}

List<Sort > sortdecl() :
{
  Set<Constant > temp;
  List<Sort > reval = new LinkedList<Sort >();
  String name;}
{
  (
    LOOKAHEAD(2)
  	(  	  name = identifier()
  	  < EQUAL >
  	  < CURLBRA >
  	  temp = constants()
  	  < CURRBRA >
  	)
  	{
  	  reval.add(new Sort(name, temp));  	}
  )+
  {
    return reval;  }
}

Set<Constant > constants() :
{
  Token t;
  Set<Constant > reval = new HashSet<Constant >();}
{
  t = < CONSTANT >
  {
    reval.add(new Constant(t.image));  }
  (
    < COMMA >
    t = < CONSTANT >
    {
      reval.add(new Constant(t.image));    }  )*
  {
    return reval;  }}

void declar(FolSignature signature) :
{
  boolean ftor = false;
  String name;
  String name2 = null;
  String temp;
  List<String > sorts = new LinkedList<String >();}
{
  (
    < TYPE > name = identifier()
    < LBRA >
    (
	  < EQUAL > name2 = identifier()
      {
        ftor = true;      }        )?
    < LBRA >
  	  (
  	    temp = identifier()
  	    {
  	      sorts.add(temp);  	    }
  	    (
  	      < COMMA >
  	      temp = identifier()
  	      {
  	        sorts.add(temp);  	      }  	    )*  	  )?
    < RBRA >
    < RBRA >
    {
      FolBasicStructure fbs;
      if(ftor)      {
        List<String > one_elem = new LinkedList<String >();
        one_elem.add(name);
        fbs = new Functor(name2,
        	getSorts(signature, sorts),
        	getSorts(signature, one_elem).get(0));      }
      else
      {
        fbs = new Predicate(name, getSorts(signature, sorts));      }
      signature.add(fbs);    }
  )*}